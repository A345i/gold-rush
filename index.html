<!DOCTYPE html>
<html lang="ru">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>–ü—Ä–æ—Å—Ç–æ–π –†–µ–¥–∞–∫—Ç–æ—Ä –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</title>
    <style>
        /* --- –û–±—â–∏–µ —Å—Ç–∏–ª–∏ --- */
        :root {
            --primary-color: #4a90e2;
            --secondary-color: #f5f5f5;
            --text-color: #333;
            --border-color: #ddd;
            --danger-color: #e74c3c;
            --success-color: #2ecc71;
            --shadow-color: rgba(0, 0, 0, 0.1);
            --font-family: -apple-system, BlinkMacSystemFont, 'Segoe UI', Roboto, Helvetica, Arial, sans-serif;
        }

        * {
            box-sizing: border-box;
            margin: 0;
            padding: 0;
        }

        html {
            font-size: 16px; /* –ë–∞–∑–æ–≤—ã–π —Ä–∞–∑–º–µ—Ä –¥–ª—è rem */
        }

        body {
            font-family: var(--font-family);
            background-color: var(--secondary-color);
            color: var(--text-color);
            display: flex;
            flex-direction: column;
            align-items: center;
            min-height: 100vh;
            padding: 1rem;
            overflow-x: hidden; /* –ü—Ä–µ–¥–æ—Ç–≤—Ä–∞—â–µ–Ω–∏–µ –≥–æ—Ä–∏–∑–æ–Ω—Ç–∞–ª—å–Ω–æ–π –ø—Ä–æ–∫—Ä—É—Ç–∫–∏ */
        }

        h1 {
            color: var(--primary-color);
            margin-bottom: 1.5rem;
            text-align: center;
            font-size: 1.8rem;
        }

        /* --- –ö–æ–Ω—Ç–µ–π–Ω–µ—Ä —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ --- */
        .editor-container {
            background-color: #fff;
            padding: 1.5rem;
            border-radius: 8px;
            box-shadow: 0 4px 15px var(--shadow-color);
            width: 100%;
            max-width: 1000px; /* –ú–∞–∫—Å–∏–º–∞–ª—å–Ω–∞—è —à–∏—Ä–∏–Ω–∞ —Ä–µ–¥–∞–∫—Ç–æ—Ä–∞ */
            display: flex;
            flex-direction: column;
            align-items: center;
        }

        /* --- –û–±–ª–∞—Å—Ç—å —É–ø—Ä–∞–≤–ª–µ–Ω–∏—è --- */
        .controls {
            display: flex;
            flex-wrap: wrap; /* –ü–µ—Ä–µ–Ω–æ—Å –∫–Ω–æ–ø–æ–∫ –Ω–∞ –Ω–æ–≤—É—é —Å—Ç—Ä–æ–∫—É */
            gap: 0.75rem; /* –†–∞—Å—Å—Ç–æ—è–Ω–∏–µ –º–µ–∂–¥—É —ç–ª–µ–º–µ–Ω—Ç–∞–º–∏ */
            margin-bottom: 1.5rem;
            justify-content: center; /* –¶–µ–Ω—Ç—Ä–∏—Ä–æ–≤–∞–Ω–∏–µ –∫–Ω–æ–ø–æ–∫ */
            width: 100%;
        }

        .control-group {
            display: flex;
            flex-wrap: wrap;
            gap: 0.5rem;
            align-items: center;
            justify-content: center;
        }

        .control-group label {
            font-size: 0.9rem;
            margin-right: 0.3rem;
            white-space: nowrap;
        }

        /* --- –°—Ç–∏–ª–∏ –∫–Ω–æ–ø–æ–∫ --- */
        button, .file-label {
            background-color: var(--primary-color);
            color: white;
            border: none;
            padding: 0.6rem 1rem;
            border-radius: 5px;
            cursor: pointer;
            font-size: 0.9rem;
            transition: background-color 0.2s ease, transform 0.1s ease, border 0.2s ease, box-shadow 0.2s ease;
            display: inline-flex;
            align-items: center;
            gap: 0.4rem;
            white-space: nowrap;
            box-shadow: 0 2px 4px rgba(0,0,0,0.1);
        }

        button:hover, .file-label:hover {
            background-color: #3a7bc8;
            box-shadow: 0 3px 6px rgba(0,0,0,0.15);
        }

        button:active, .file-label:active {
            transform: scale(0.98);
            box-shadow: 0 1px 2px rgba(0,0,0,0.1);
        }

        button:disabled {
            background-color: #ccc;
            cursor: not-allowed;
            box-shadow: none;
        }

        #resetButton { background-color: var(--danger-color); }
        #resetButton:hover { background-color: #c0392b; }
        #saveButton { background-color: var(--success-color); }
        #saveButton:hover { background-color: #27ae60; }

        /* –°–∫—Ä—ã—Ç–∏–µ —Å—Ç–∞–Ω–¥–∞—Ä—Ç–Ω–æ–≥–æ input[type=file] */
        #imageLoader { display: none; }

        /* --- –ü–æ–ª–∑—É–Ω–∫–∏ --- */
        input[type="range"] {
            cursor: pointer;
            max-width: 100px;
            vertical-align: middle;
        }

        /* --- –û–±–ª–∞—Å—Ç—å —Ö–æ–ª—Å—Ç–∞ --- */
        .canvas-wrapper {
            position: relative;
            width: 100%;
            max-width: 800px;
            margin: 0 auto;
            background-color: #e9e9e9;
            overflow: hidden;
            border: 1px solid var(--border-color);
            min-height: 200px;
            display: flex;
            justify-content: center;
            align-items: center;
            transition: border-color 0.3s ease, background-color 0.3s ease;
            border-radius: 4px;
            user-select: none;
             -webkit-user-select: none;
             -moz-user-select: none;
             -ms-user-select: none;
        }

        #imageCanvas {
            display: block;
            max-width: 100%;
            max-height: 70vh;
            object-fit: contain;
            cursor: default;
        }

        /* --- –û–±–ª–∞—Å—Ç—å –≤—ã–¥–µ–ª–µ–Ω–∏—è –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ --- */
        #selectionRect {
            position: absolute;
            border: 2px dashed var(--danger-color);
            background-color: rgba(231, 76, 60, 0.2);
            cursor: move;
            display: none;
            pointer-events: none;
            z-index: 5;
        }

         /* –£–∫–∞–∑–∞—Ç–µ–ª–∏ –∏–∑–º–µ–Ω–µ–Ω–∏—è —Ä–∞–∑–º–µ—Ä–∞ */
        .resizer {
            position: absolute;
            width: 10px;
            height: 10px;
            background-color: var(--danger-color);
            border: 1px solid white;
            border-radius: 50%;
            pointer-events: all !important;
            z-index: 10;
        }
        .resizer.top-left { top: -6px; left: -6px; cursor: nwse-resize; }
        .resizer.top-right { top: -6px; right: -6px; cursor: nesw-resize; }
        .resizer.bottom-left { bottom: -6px; left: -6px; cursor: nesw-resize; }
        .resizer.bottom-right { bottom: -6px; right: -6px; cursor: nwse-resize; }
        .resizer.top { top: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resizer.bottom { bottom: -6px; left: 50%; transform: translateX(-50%); cursor: ns-resize; }
        .resizer.left { top: 50%; left: -6px; transform: translateY(-50%); cursor: ew-resize; }
        .resizer.right { top: 50%; right: -6px; transform: translateY(-50%); cursor: ew-resize; }

        /* --- –°–æ–æ–±—â–µ–Ω–∏–µ –æ –∑–∞–≥—Ä—É–∑–∫–µ --- */
        #initialMessage {
            color: #888;
            text-align: center;
            padding: 2rem;
            font-size: 1.1rem;
            pointer-events: none;
        }

        /* --- –°—Ç–∏–ª–∏ –¥–ª—è Drag & Drop --- */
        .canvas-wrapper.drag-over {
            border: 3px dashed var(--primary-color);
            background-color: rgba(74, 144, 226, 0.1);
        }
        .canvas-wrapper.drag-over #initialMessage::before {
            content: "–ü–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ —Å—é–¥–∞ üëá";
            display: block;
            color: var(--primary-color);
            font-weight: bold;
            margin-bottom: 0.5rem;
            font-size: 1.2rem;
        }
        .canvas-wrapper.drag-over #initialMessage { color: var(--primary-color); }

        /* --- –ê–¥–∞–ø—Ç–∏–≤–Ω–æ—Å—Ç—å --- */
        @media (max-width: 768px) {
            .editor-container { padding: 1rem; }
            h1 { font-size: 1.5rem; margin-bottom: 1rem; }
            .controls { gap: 0.5rem; margin-bottom: 1rem; }
            button, .file-label { padding: 0.5rem 0.8rem; font-size: 0.85rem; }
            .control-group { flex-direction: column; align-items: stretch; width: auto; flex-basis: 120px; text-align: center; }
            .control-group label { margin-bottom: 0.2rem; margin-right: 0; }
            input[type="range"] { max-width: 100%; width: 100%; margin: 0.2rem auto 0; }
        }
        @media (max-width: 480px) {
            h1 { font-size: 1.3rem; }
            .controls { flex-direction: column; align-items: stretch; }
            button, .file-label { width: 100%; justify-content: center; padding: 0.7rem 1rem; }
            .control-group { gap: 0.5rem; width: 100%; flex-basis: auto; margin-bottom: 0.5rem; }
            .canvas-wrapper { min-height: 150px; }
            #initialMessage { font-size: 1rem; padding: 1rem; }
        }
    </style>
</head>
<body>

    <h1>üé® –ü—Ä–æ—Å—Ç–æ–π –†–µ–¥–∞–∫—Ç–æ—Ä –ò–∑–æ–±—Ä–∞–∂–µ–Ω–∏–π</h1>

    <div class="editor-container">
        <!-- –ü–∞–Ω–µ–ª—å –£–ø—Ä–∞–≤–ª–µ–Ω–∏—è -->
        <div class="controls">
            <label for="imageLoader" class="file-label">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 1.146a.5.5 0 0 1 .708 0l3 3a.5.5 0 0 1-.708.708L8.5 2.707V11.5a.5.5 0 0 1-1 0V2.707L5.354 4.854a.5.5 0 1 1-.708-.708z"/></svg>
                –ó–∞–≥—Ä—É–∑–∏—Ç—å
            </label>
            <input type="file" id="imageLoader" accept="image/*">

            <button id="rotateLeft" disabled title="–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ª–µ–≤–æ">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 0 4.546 2.914.5.5 0 0 1 .908-.417A6 6 0 1 1 8 2z"/><path d="M8 4.466V.534a.25.25 0 0 1 .41-.192l2.36 1.966c.12.1.12.284 0 .384L8.41 4.658A.25.25 0 0 1 8 4.466"/></svg>
                –í–ª–µ–≤–æ
            </button>
            <button id="rotateRight" disabled title="–ü–æ–≤–µ—Ä–Ω—É—Ç—å –≤–ø—Ä–∞–≤–æ">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 1-.908-.417A6 6 0 1 0 8 2z"/><path d="M7.5 4a.5.5 0 0 1 .5.5v3.5h3.5a.5.5 0 0 1 0 1h-4a.5.5 0 0 1-.5-.5V4.5a.5.5 0 0 1 .5-.5"/></svg>
               –í–ø—Ä–∞–≤–æ
            </button>
            <button id="cropToggle" disabled title="–í—ã–¥–µ–ª–∏—Ç—å/–û–±—Ä–µ–∑–∞—Ç—å">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" id="cropIconSelect"><path d="M3.5.5A.5.5 0 0 1 4 1v13h1V1a.5.5 0 0 1 1 0v13h1V1a.5.5 0 0 1 1 0v13h1V1a.5.5 0 0 1 1 0v13h1V1a.5.5 0 0 1 .5.5v14a.5.5 0 0 1-.5.5H.5a.5.5 0 0 1-.5-.5v-14a.5.5 0 0 1 .5-.5H3z"/><path d="M15.5 3.5a.5.5 0 0 1 .5.5v1H.5a.5.5 0 0 1 0-1H1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1v1h1v-1h1V4a.5.5 0 0 1 .5-.5zM.5 11.5a.5.5 0 0 1 .5.5v1h13v-1a.5.5 0 0 1 1 0v1.5a.5.5 0 0 1-.5.5h-14a.5.5 0 0 1-.5-.5V12a.5.5 0 0 1 .5-.5z"/></svg>
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16" id="cropIconApply" style="display: none;"><path d="M8.158 1 H.5a.5.5 0 0 0-.5.5v6.586a.5.5 0 0 0 1 0V1.5h6.658a.5.5 0 0 0 0-1m7.342 7.342V14.5a.5.5 0 0 1-.5.5H8.158a.5.5 0 0 1 0-1H14.5V8.158a.5.5 0 0 1 1 0"/><path d="M14.5 1.5a.5.5 0 0 1 .5.5v6.586l-1-1V2.5h-5.086l-1-1zM1.5 14.5a.5.5 0 0 1-.5-.5V8.158l1 1v5.086h5.086l1 1z"/></svg>
                 <span id="cropToggleText">–í—ã–¥–µ–ª–∏—Ç—å</span>
            </button>

            <div class="control-group">
                <label for="brightnessSlider">–Ø—Ä–∫–æ—Å—Ç—å:</label>
                <input type="range" id="brightnessSlider" min="0" max="200" value="100" disabled>
            </div>
             <div class="control-group">
                <label for="contrastSlider">–ö–æ–Ω—Ç—Ä–∞—Å—Ç:</label>
                <input type="range" id="contrastSlider" min="0" max="200" value="100" disabled>
            </div>

            <button id="resetButton" disabled title="–°–±—Ä–æ—Å–∏—Ç—å –∏–∑–º–µ–Ω–µ–Ω–∏—è">
                 <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path fill-rule="evenodd" d="M8 3a5 5 0 1 1-4.546 2.914.5.5 0 0 0-.908-.417A6 6 0 1 0 8 2zm0 4.466V.534a.25.25 0 0 0-.41-.192L5.23 2.308a.25.25 0 0 0 0 .384l2.36 1.966A.25.25 0 0 0 8 4.466"/></svg>
                –°–±—Ä–æ—Å
            </button>
            <button id="saveButton" disabled title="–°–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ">
                <svg xmlns="http://www.w3.org/2000/svg" width="16" height="16" fill="currentColor" viewBox="0 0 16 16"><path d="M.5 9.9a.5.5 0 0 1 .5.5v2.5a1 1 0 0 0 1 1h12a1 1 0 0 0 1-1v-2.5a.5.5 0 0 1 1 0v2.5a2 2 0 0 1-2 2H2a2 2 0 0 1-2-2v-2.5a.5.5 0 0 1 .5-.5"/><path d="M7.646 11.854a.5.5 0 0 0 .708 0l3-3a.5.5 0 0 0-.708-.708L8.5 10.293V1.5a.5.5 0 0 0-1 0v8.793L5.354 8.146a.5.5 0 1 0-.708.708z"/></svg>
                –°–æ—Ö—Ä–∞–Ω–∏—Ç—å
            </button>
        </div>

        <!-- –û–±–ª–∞—Å—Ç—å –•–æ–ª—Å—Ç–∞ –∏ –í—ã–¥–µ–ª–µ–Ω–∏—è -->
        <div class="canvas-wrapper" id="canvasWrapper">
            <canvas id="imageCanvas"></canvas>
            <div id="selectionRect">
                <!-- Resizers -->
                <div class="resizer top-left"></div>
                <div class="resizer top-right"></div>
                <div class="resizer bottom-left"></div>
                <div class="resizer bottom-right"></div>
                <div class="resizer top"></div>
                <div class="resizer bottom"></div>
                <div class="resizer left"></div>
                <div class="resizer right"></div>
            </div>
             <div id="initialMessage">–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ<br>–∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –µ–≥–æ —Å—é–¥–∞</div>
        </div>
    </div>

    <script>
        // --- DOM Elements ---
        const imageLoader = document.getElementById('imageLoader');
        const canvas = document.getElementById('imageCanvas');
        const ctx = canvas.getContext('2d');
        const canvasWrapper = document.getElementById('canvasWrapper');
        const selectionRectDiv = document.getElementById('selectionRect');
        const initialMessage = document.getElementById('initialMessage');
        const rotateLeftBtn = document.getElementById('rotateLeft');
        const rotateRightBtn = document.getElementById('rotateRight');
        const cropToggleBtn = document.getElementById('cropToggle');
        const cropIconSelect = document.getElementById('cropIconSelect');
        const cropIconApply = document.getElementById('cropIconApply');
        const cropToggleText = document.getElementById('cropToggleText');
        const resetButton = document.getElementById('resetButton');
        const saveButton = document.getElementById('saveButton');
        const brightnessSlider = document.getElementById('brightnessSlider');
        const contrastSlider = document.getElementById('contrastSlider');
        const resizers = document.querySelectorAll('.resizer');

        // --- State Variables ---
        let originalImage = null;         // The very first loaded Image object
        let currentImageState = null;    // Represents the image data *currently* being manipulated (can be original or cropped)
                                         // This will store an ImageBitmap or an Image object
        let originalImageDataURL = null; // For reset functionality
        let currentRotation = 0;         // Degrees, applied only during drawing, not baked into currentImageState unless cropped
        let currentBrightness = 100;
        let currentContrast = 100;
        let isCroppingMode = false;
        let isDraggingSelection = false;
        let isResizing = false;
        let startX, startY;              // Mouse start position relative to wrapper
        let selection = { x: 0, y: 0, width: 0, height: 0, active: false, initial: null }; // Selection coords relative to wrapper
        let resizeHandle = null;
        let viewScale = 1; // Scale factor used to draw the image on canvas

        // --- Initialization ---
        window.addEventListener('DOMContentLoaded', () => {
            updateButtonStates();
            setupDragAndDrop();
        });

        // --- Image Loading ---
        function loadImageFromFile(file) {
            if (!file || !file.type.startsWith('image/')) {
                alert('–ü–æ–∂–∞–ª—É–π—Å—Ç–∞, –≤—ã–±–µ—Ä–∏—Ç–µ —Ñ–∞–π–ª –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏—è.');
                if (imageLoader.value) imageLoader.value = null;
                return;
            }

            const reader = new FileReader();
            reader.onload = (event) => {
                originalImage = new Image();
                originalImage.onload = async () => {
                    try {
                        // Use createImageBitmap for better performance and off-thread decoding potential
                        currentImageState = await createImageBitmap(originalImage);
                        originalImageDataURL = event.target.result;
                        resetStateToOriginal(); // Includes redraw
                        initialMessage.style.display = 'none';
                        canvas.style.display = 'block';
                        updateButtonStates();
                        canvas.style.cursor = 'default';
                        if(isCroppingMode) resetCropMode();
                    } catch (error) {
                        console.error("Error creating ImageBitmap:", error);
                        alert('–ù–µ —É–¥–∞–ª–æ—Å—å –æ–±—Ä–∞–±–æ—Ç–∞—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
                        resetEditor();
                    }
                };
                originalImage.onerror = () => {
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å –∑–∞–≥—Ä—É–∑–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
                    resetEditor();
                };
                originalImage.src = event.target.result;
            };
            reader.onerror = () => {
                alert('–û—à–∏–±–∫–∞ —á—Ç–µ–Ω–∏—è —Ñ–∞–π–ª–∞.');
                resetEditor();
            };
            reader.readAsDataURL(file);
            if (imageLoader.value) imageLoader.value = null;
        }

        imageLoader.addEventListener('change', (e) => {
            const file = e.target.files[0];
            if (file) loadImageFromFile(file);
        });

        // --- Drag and Drop Setup ---
        function setupDragAndDrop() {
            ['dragenter', 'dragover', 'dragleave', 'drop'].forEach(eventName => {
                canvasWrapper.addEventListener(eventName, preventDefaults, false);
                document.body.addEventListener(eventName, preventDefaults, false);
            });
            function preventDefaults(e) { e.preventDefault(); e.stopPropagation(); }
            ['dragenter', 'dragover'].forEach(eventName => canvasWrapper.addEventListener(eventName, highlight, false));
            ['dragleave', 'drop'].forEach(eventName => canvasWrapper.addEventListener(eventName, unhighlight, false));
            function highlight(e) { if (e.dataTransfer.types && Array.from(e.dataTransfer.types).includes('Files')) { canvasWrapper.classList.add('drag-over'); }}
            function unhighlight(e) { canvasWrapper.classList.remove('drag-over'); }
            canvasWrapper.addEventListener('drop', (e) => {
                const files = e.dataTransfer.files;
                if (files.length > 0) loadImageFromFile(files[0]);
                else console.warn("–ü–µ—Ä–µ—Ç–∞—â–µ–Ω–Ω—ã–π —ç–ª–µ–º–µ–Ω—Ç –Ω–µ —è–≤–ª—è–µ—Ç—Å—è —Ñ–∞–π–ª–æ–º.");
            }, false);
        }

        // --- Drawing Logic ---
        function redrawCanvas() {
            if (!currentImageState) return;

            const imgWidth = currentImageState.width; // Use ImageBitmap dimensions
            const imgHeight = currentImageState.height;
            const rad = currentRotation * Math.PI / 180;
            const absCos = Math.abs(Math.cos(rad));
            const absSin = Math.abs(Math.sin(rad));
            const rotatedBoundingBoxWidth = imgWidth * absCos + imgHeight * absSin;
            const rotatedBoundingBoxHeight = imgWidth * absSin + imgHeight * absCos;

            const maxWidth = canvasWrapper.clientWidth;
            const maxHeight = window.innerHeight * 0.7; // Limit canvas height

            // Calculate scale to fit, store it globally for coordinate mapping
            const scaleWidth = maxWidth > 0 ? maxWidth / rotatedBoundingBoxWidth : 1;
            const scaleHeight = maxHeight > 0 ? maxHeight / rotatedBoundingBoxHeight : 1;
            viewScale = Math.min(scaleWidth, scaleHeight, 1); // Don't scale up

            // Set actual canvas drawing size
            canvas.width = rotatedBoundingBoxWidth * viewScale;
            canvas.height = rotatedBoundingBoxHeight * viewScale;

            ctx.clearRect(0, 0, canvas.width, canvas.height);
            ctx.save();
            // Apply filters
            ctx.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;
            // Translate, rotate, draw centered
            ctx.translate(canvas.width / 2, canvas.height / 2);
            ctx.rotate(rad);
            const drawWidth = imgWidth * viewScale;
            const drawHeight = imgHeight * viewScale;
            // Use ImageBitmap directly in drawImage
            ctx.drawImage(currentImageState, -drawWidth / 2, -drawHeight / 2, drawWidth, drawHeight);
            ctx.restore();

            // Update selection visuals if necessary
            if (isCroppingMode && selection.active) {
                 clampSelectionToCanvas(); // Re-clamp based on potentially new canvas size/position
                 updateSelectionRectVisuals();
            } else {
                hideSelectionRect();
            }
        }

        // --- Controls ---
        rotateLeftBtn.addEventListener('click', () => { if (!isCroppingMode) { currentRotation = (currentRotation - 90 + 360) % 360; redrawCanvas(); }});
        rotateRightBtn.addEventListener('click', () => { if (!isCroppingMode) { currentRotation = (currentRotation + 90) % 360; redrawCanvas(); }});
        brightnessSlider.addEventListener('input', (e) => { if (!isCroppingMode) { currentBrightness = e.target.value; redrawCanvas(); }});
        contrastSlider.addEventListener('input', (e) => { if (!isCroppingMode) { currentContrast = e.target.value; redrawCanvas(); }});

        resetButton.addEventListener('click', async () => {
            if (originalImage) { // Check if originalImage exists
                try {
                    // Recreate ImageBitmap from the original Image object
                    currentImageState = await createImageBitmap(originalImage);
                    resetStateToOriginal(); // Resets transforms, redraws, updates buttons
                } catch (error) {
                    console.error("Error recreating ImageBitmap on reset:", error);
                    alert('–ù–µ —É–¥–∞–ª–æ—Å—å —Å–±—Ä–æ—Å–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ.');
                    resetEditor(); // Fallback to full reset
                }
            }
        });

        saveButton.addEventListener('click', async () => {
            if (!currentImageState) return;

             console.log('Saving image state with dimensions:', currentImageState.width, 'x', currentImageState.height);

            // Create a temporary canvas for saving
            const tempCanvas = document.createElement('canvas');
            const tempCtx = tempCanvas.getContext('2d');

            // Set canvas size to the exact dimensions of the current image state
            tempCanvas.width = currentImageState.width;
            tempCanvas.height = currentImageState.height;

            // --- Apply transformations *only if* they haven't been baked in by a crop ---
            // If rotation is 0 and filters are default, we can draw directly.
            // Otherwise, apply the current rotation/filters to the temp canvas before drawing.
            if (currentRotation !== 0 || currentBrightness !== 100 || currentContrast !== 100) {
                 console.log('Applying final transforms for saving:', { currentRotation, currentBrightness, currentContrast });
                 const rad = currentRotation * Math.PI / 180;
                 const absCos = Math.abs(Math.cos(rad));
                 const absSin = Math.abs(Math.sin(rad));

                 // Adjust canvas size if rotation needs to be applied
                 tempCanvas.width = Math.round(currentImageState.width * absCos + currentImageState.height * absSin);
                 tempCanvas.height = Math.round(currentImageState.width * absSin + currentImageState.height * absCos);

                 tempCtx.filter = `brightness(${currentBrightness}%) contrast(${currentContrast}%)`;
                 tempCtx.translate(tempCanvas.width / 2, tempCanvas.height / 2);
                 tempCtx.rotate(rad);
                 // Draw centered on the potentially larger rotated canvas
                 tempCtx.drawImage(
                     currentImageState,
                     -currentImageState.width / 2,
                     -currentImageState.height / 2,
                     currentImageState.width,
                     currentImageState.height
                 );
            } else {
                 // No rotation or filters to apply (either reset or baked in by crop)
                 console.log('Drawing directly for saving (no extra transforms).');
                 tempCtx.drawImage(
                     currentImageState,
                     0, 0,
                     currentImageState.width,
                     currentImageState.height
                 );
            }

            // --- Create download link ---
            const link = document.createElement('a');
            const timestamp = new Date().toISOString().replace(/[:.-]/g, '').slice(0, 15);
            link.download = `edited-${timestamp}.png`;
            try {
                 link.href = tempCanvas.toDataURL('image/png');
                 document.body.appendChild(link);
                 link.click();
                 document.body.removeChild(link);
            } catch (e) {
                 console.error("–û—à–∏–±–∫–∞ –ø—Ä–∏ —Å–æ–∑–¥–∞–Ω–∏–∏ Data URL –∏–ª–∏ —Å–∫–∞—á–∏–≤–∞–Ω–∏–∏:", e);
                 alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Å–æ—Ö—Ä–∞–Ω–∏—Ç—å –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ. –í–æ–∑–º–æ–∂–Ω–∞—è –ø—Ä–∏—á–∏–Ω–∞: –æ—à–∏–±–∫–∞ –±–µ–∑–æ–ø–∞—Å–Ω–æ—Å—Ç–∏ —Ö–æ–ª—Å—Ç–∞ (cross-origin).");
            }
        });


        // --- Cropping Logic ---

        cropToggleBtn.addEventListener('click', () => {
            isCroppingMode = !isCroppingMode;
            if (isCroppingMode) {
                // Enter crop mode
                canvasWrapper.style.cursor = 'crosshair';
                canvas.style.cursor = 'crosshair';
                canvasWrapper.addEventListener('mousedown', handleMouseDown);
                resetSelection();
                updateButtonStates();
            } else {
                // Exit or Apply crop
                if (selection.active && selection.width > 5 && selection.height > 5) {
                    performCrop(); // Attempt to apply crop
                } else {
                    resetCropMode(); // Just exit if no valid selection
                }
            }
        });

         function resetCropMode() {
            isCroppingMode = false;
            canvasWrapper.style.cursor = 'default';
            canvas.style.cursor = 'default';
            hideSelectionRect();
            resetSelection();
            canvasWrapper.removeEventListener('mousedown', handleMouseDown);
            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
            updateButtonStates();
        }

        function handleMouseDown(e) {
            if (!isCroppingMode || !currentImageState) return;
            e.preventDefault();

            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const mouseX = e.clientX - wrapperRect.left;
            const mouseY = e.clientY - wrapperRect.top;

            if (e.target.classList.contains('resizer')) {
                isResizing = true; isDraggingSelection = false;
                resizeHandle = e.target.classList.value.replace('resizer ', '').trim();
                startX = mouseX; startY = mouseY;
                selection.initial = { ...selection };
                canvasWrapper.style.cursor = getComputedStyle(e.target).cursor;
            } else if (selection.active && isPointInSelection(mouseX, mouseY)) {
                isDraggingSelection = true; isResizing = false;
                startX = mouseX - selection.x; startY = mouseY - selection.y;
                canvasWrapper.style.cursor = 'move';
            } else {
                isDraggingSelection = false; isResizing = false;
                selection.active = true;
                selection.x = mouseX; selection.y = mouseY;
                selection.width = 0; selection.height = 0;
                selection.initial = null; // Mark as drawing new box
                startX = mouseX; startY = mouseY;
                showSelectionRect();
                updateSelectionRectVisuals();
                canvasWrapper.style.cursor = 'crosshair';
            }

            window.addEventListener('mousemove', handleMouseMove);
            window.addEventListener('mouseup', handleMouseUp);
        }

        function handleMouseMove(e) {
            if (!selection.active || (!isDraggingSelection && !isResizing && selection.initial !== null)) return;

            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const mouseX = e.clientX - wrapperRect.left;
            const mouseY = e.clientY - wrapperRect.top;
            let newX = selection.x, newY = selection.y, newW = selection.width, newH = selection.height;

            if (isResizing) {
                const dx = mouseX - startX; const dy = mouseY - startY;
                const initial = selection.initial;
                newX = initial.x; newY = initial.y; newW = initial.width; newH = initial.height;
                const minSize = 5;

                if (resizeHandle.includes('right')) newW = Math.max(minSize, initial.width + dx);
                if (resizeHandle.includes('bottom')) newH = Math.max(minSize, initial.height + dy);
                if (resizeHandle.includes('left')) {
                    const potentialW = initial.width - dx;
                    if (potentialW >= minSize) { newW = potentialW; newX = initial.x + dx; }
                    else { newW = minSize; newX = initial.x + initial.width - minSize; }
                }
                if (resizeHandle.includes('top')) {
                    const potentialH = initial.height - dy;
                    if (potentialH >= minSize) { newH = potentialH; newY = initial.y + dy; }
                    else { newH = minSize; newY = initial.y + initial.height - minSize; }
                }
                selection.x = newX; selection.y = newY; selection.width = newW; selection.height = newH;
            } else if (isDraggingSelection) {
                selection.x = mouseX - startX; selection.y = mouseY - startY;
            } else { // Drawing new box
                selection.x = Math.min(mouseX, startX);
                selection.y = Math.min(mouseY, startY);
                selection.width = Math.abs(mouseX - startX);
                selection.height = Math.abs(mouseY - startY);
            }

            clampSelectionToCanvas();
            updateSelectionRectVisuals();
        }

        function handleMouseUp() {
            if (selection.active && (selection.width < 5 || selection.height < 5) && !isDraggingSelection && !isResizing) {
                // If a new box was drawn too small, deactivate selection
                resetSelection();
            }
            isDraggingSelection = false; isResizing = false;
            resizeHandle = null; selection.initial = null;

            if (isCroppingMode) canvasWrapper.style.cursor = 'crosshair';
            else canvasWrapper.style.cursor = 'default';

            window.removeEventListener('mousemove', handleMouseMove);
            window.removeEventListener('mouseup', handleMouseUp);
            if (selection.active) updateSelectionRectVisuals(); // Final update
        }

        function clampSelectionToCanvas() {
            if (!canvas || !selection.active || canvas.width === 0) return;
            const canvasRect = canvas.getBoundingClientRect();
            const wrapperRect = canvasWrapper.getBoundingClientRect();
            const canvasMinX = canvasRect.left - wrapperRect.left;
            const canvasMinY = canvasRect.top - wrapperRect.top;
            const canvasMaxX = canvasMinX + canvasRect.width;
            const canvasMaxY = canvasMinY + canvasRect.height;

            let { x: selX, y: selY, width: selW, height: selH } = selection; // Destructure

            // Clamp top-left
            selX = Math.max(canvasMinX, selX);
            selY = Math.max(canvasMinY, selY);

            // Clamp bottom-right based on clamped top-left
            if (selX + selW > canvasMaxX) selW = Math.max(0, canvasMaxX - selX);
            if (selY + selH > canvasMaxY) selH = Math.max(0, canvasMaxY - selY);

            // Ensure width/height are not negative after clamping (can happen if selX/selY was already > canvasMaxX/Y)
            selW = Math.max(0, selW);
            selH = Math.max(0, selH);

            // Update selection object
            selection.x = selX; selection.y = selY; selection.width = selW; selection.height = selH;
        }

         function updateSelectionRectVisuals() {
             if (!selection.active) { hideSelectionRect(); return; }
             const displayX = Math.round(selection.x);
             const displayY = Math.round(selection.y);
             const displayWidth = Math.round(Math.max(0, selection.width));
             const displayHeight = Math.round(Math.max(0, selection.height));
             const minDisplaySize = 3;

             selectionRectDiv.style.left = `${displayX}px`;
             selectionRectDiv.style.top = `${displayY}px`;
             selectionRectDiv.style.width = `${displayWidth}px`;
             selectionRectDiv.style.height = `${displayHeight}px`;
             selectionRectDiv.style.display = (displayWidth >= minDisplaySize && displayHeight >= minDisplaySize) ? 'block' : 'none';
         }

         function showSelectionRect() {
             selectionRectDiv.style.display = 'block'; // Make div element available
             if(selection.active) updateSelectionRectVisuals(); // Apply current state (might hide if 0 size)
         }
         function hideSelectionRect() { selectionRectDiv.style.display = 'none'; }
         function resetSelection() { selection = { x: 0, y: 0, width: 0, height: 0, active: false, initial: null }; hideSelectionRect(); }
         function isPointInSelection(px, py) {
             if (!selection.active || selection.width <= 0 || selection.height <= 0) return false;
             const tolerance = 2;
             return px >= selection.x - tolerance && px < selection.x + selection.width + tolerance &&
                    py >= selection.y - tolerance && py < selection.y + selection.height + tolerance;
         }

        async function performCrop() {
            if (!selection.active || selection.width <= 5 || selection.height <= 5 || !currentImageState) {
                alert("–í—ã–¥–µ–ª–µ–Ω–∏–µ –¥–ª—è –æ–±—Ä–µ–∑–∫–∏ —Å–ª–∏—à–∫–æ–º –º–∞–ª–µ–Ω—å–∫–æ–µ –∏–ª–∏ –æ—Ç—Å—É—Ç—Å—Ç–≤—É–µ—Ç.");
                resetCropMode(); return;
            }

            try {
                // --- Calculate Crop Region in *Original Image* Coordinates ---
                // 1. Get selection relative to visible canvas
                const canvasRect = canvas.getBoundingClientRect();
                const wrapperRect = canvasWrapper.getBoundingClientRect();
                const canvasOffsetX = canvasRect.left - wrapperRect.left;
                const canvasOffsetY = canvasRect.top - wrapperRect.top;
                const selX_view = selection.x - canvasOffsetX; // Selection X relative to canvas view
                const selY_view = selection.y - canvasOffsetY; // Selection Y relative to canvas view
                const selW_view = selection.width;
                const selH_view = selection.height;

                // 2. Map view coordinates back to original image coordinates (inverse scale)
                // Need to account for the centering offset used in redrawCanvas
                const drawWidth = currentImageState.width * viewScale;
                const drawHeight = currentImageState.height * viewScale;
                // Calculate the top-left corner where the scaled image *starts* drawing within the canvas buffer
                const imgDrawOffsetX = (canvas.width - drawWidth) / 2;
                const imgDrawOffsetY = (canvas.height - drawHeight) / 2;

                // Selection coordinates relative to the *drawn image* (at viewScale)
                const selX_img_scaled = selX_view - imgDrawOffsetX;
                const selY_img_scaled = selY_view - imgDrawOffsetY;

                 // Convert scaled image coordinates to original image coordinates
                 // Important: This simplified mapping works correctly only when currentRotation is 0.
                 // If rotation is non-zero during crop selection, the mapping is much more complex.
                 // For simplicity, let's assume rotation is reset or baked in before crop selection,
                 // or disable crop if rotation is not 0.
                 if (currentRotation !== 0) {
                     alert("–û–±—Ä–µ–∑–∫–∞ –ø—Ä–∏–º–µ–Ω–µ–Ω–Ω–æ–≥–æ –ø–æ–≤–æ—Ä–æ—Ç–∞ –ø–æ–∫–∞ –Ω–µ –ø–æ–¥–¥–µ—Ä–∂–∏–≤–∞–µ—Ç—Å—è. –°–±—Ä–æ—Å—å—Ç–µ –ø–æ–≤–æ—Ä–æ—Ç –∏–ª–∏ —Å–æ—Ö—Ä–∞–Ω–∏—Ç–µ/–∑–∞–≥—Ä—É–∑–∏—Ç–µ –ø–æ–≤–µ—Ä–Ω—É—Ç–æ–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ –ø–µ—Ä–µ–¥ –æ–±—Ä–µ–∑–∫–æ–π.");
                     resetCropMode(); // Exit crop mode
                     return;
                 }

                const srcX = Math.round(selX_img_scaled / viewScale);
                const srcY = Math.round(selY_img_scaled / viewScale);
                const srcW = Math.round(selW_view / viewScale);
                const srcH = Math.round(selH_view / viewScale);

                // 3. Clamp source coordinates to the actual image dimensions
                const imgW = currentImageState.width;
                const imgH = currentImageState.height;
                const finalSrcX = Math.max(0, Math.min(srcX, imgW));
                const finalSrcY = Math.max(0, Math.min(srcY, imgH));
                const finalSrcW = Math.max(0, Math.min(srcW, imgW - finalSrcX)); // Width cannot exceed remaining image width
                const finalSrcH = Math.max(0, Math.min(srcH, imgH - finalSrcY)); // Height cannot exceed remaining image height

                console.log('Original Crop Coords:', { x: finalSrcX, y: finalSrcY, w: finalSrcW, h: finalSrcH });

                if (finalSrcW <= 0 || finalSrcH <= 0) {
                    console.error("Calculated source crop area is invalid.");
                    alert("–ù–µ —É–¥–∞–ª–æ—Å—å —Ä–∞—Å—Å—á–∏—Ç–∞—Ç—å –æ–±–ª–∞—Å—Ç—å –æ–±—Ä–µ–∑–∫–∏ –Ω–∞ –∏—Å—Ö–æ–¥–Ω–æ–º –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–∏.");
                    resetSelection(); hideSelectionRect(); return;
                }

                // 4. Create new ImageBitmap using the calculated source rectangle
                const croppedBitmap = await createImageBitmap(
                    currentImageState, // Source ImageBitmap
                    finalSrcX, finalSrcY, finalSrcW, finalSrcH
                );

                // 5. Update state
                // Close the previous bitmap to free memory (if it exists and has close method)
                if (currentImageState && typeof currentImageState.close === 'function') {
                     currentImageState.close();
                }
                currentImageState = croppedBitmap; // Replace with the new cropped bitmap

                // Reset transformations as they are conceptually baked into the new state
                currentRotation = 0;
                currentBrightness = 100; // Reset filters as well, assuming crop is the primary operation
                currentContrast = 100;
                brightnessSlider.value = 100;
                contrastSlider.value = 100;

                resetCropMode(); // Exit UI crop mode
                redrawCanvas(); // Redraw with the new cropped image state

            } catch (error) {
                console.error("Error during crop operation:", error);
                alert("–ü—Ä–æ–∏–∑–æ—à–ª–∞ –æ—à–∏–±–∫–∞ –≤–æ –≤—Ä–µ–º—è –æ–±—Ä–µ–∑–∫–∏.");
                resetCropMode(); // Ensure exiting crop mode on error
            }
        }


        // --- Utility Functions ---

        function updateButtonStates() {
            const hasImage = !!currentImageState;
            const enableControls = hasImage && !isCroppingMode;

            rotateLeftBtn.disabled = !enableControls;
            rotateRightBtn.disabled = !enableControls;
            brightnessSlider.disabled = !enableControls;
            contrastSlider.disabled = !enableControls;
            cropToggleBtn.disabled = !hasImage || currentRotation !== 0; // Disable crop if rotated
             resetButton.disabled = !hasImage;
            saveButton.disabled = !hasImage;

            // Update Crop Button Visuals
            if(hasImage){
                 cropToggleBtn.title = currentRotation !== 0 ? '–°–±—Ä–æ—Å—å—Ç–µ –ø–æ–≤–æ—Ä–æ—Ç –¥–ª—è –æ–±—Ä–µ–∑–∫–∏' : (isCroppingMode ? '–ü—Ä–∏–º–µ–Ω–∏—Ç—å –æ–±—Ä–µ–∑–∫—É' : '–í—ã–¥–µ–ª–∏—Ç—å –æ–±–ª–∞—Å—Ç—å');
            }

            cropIconSelect.style.display = isCroppingMode ? 'none' : 'inline';
            cropIconApply.style.display = isCroppingMode ? 'inline' : 'none';
            cropToggleText.textContent = isCroppingMode ? '–û–±—Ä–µ–∑–∞—Ç—å' : '–í—ã–¥–µ–ª–∏—Ç—å';
        }

        function resetStateToOriginal() {
            // This function assumes currentImageState has been reset to the original bitmap
            currentRotation = 0;
            currentBrightness = 100;
            currentContrast = 100;
            brightnessSlider.value = 100;
            contrastSlider.value = 100;
            if (isCroppingMode) resetCropMode();
            else resetSelection();
            redrawCanvas();
            updateButtonStates();
        }

        function resetEditor() {
             if (currentImageState && typeof currentImageState.close === 'function') {
                 currentImageState.close(); // Free memory if possible
             }
             originalImage = null;
             currentImageState = null;
             originalImageDataURL = null;
             ctx.clearRect(0, 0, canvas.width, canvas.height);
             canvas.width = 0; canvas.height = 0;
             initialMessage.innerHTML = "–ó–∞–≥—Ä—É–∑–∏—Ç–µ –∏–∑–æ–±—Ä–∞–∂–µ–Ω–∏–µ<br>–∏–ª–∏ –ø–µ—Ä–µ—Ç–∞—â–∏—Ç–µ –µ–≥–æ —Å—é–¥–∞";
             initialMessage.style.display = 'block';
             canvas.style.display = 'none';
             canvasWrapper.classList.remove('drag-over');
             resetStateToOriginal(); // Reset sliders, buttons etc.
        }

        // Debounced resize handler
        let resizeTimer;
        window.addEventListener('resize', () => {
            clearTimeout(resizeTimer);
            resizeTimer = setTimeout(() => {
                if (currentImageState) redrawCanvas();
            }, 150);
        });

    </script>

</body>
</html>